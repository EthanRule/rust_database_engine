use database::storage::file::DatabaseFile;
use database::storage::storage_engine::StorageEngine;
use database::{Document, Value};
use tempfile::tempdir;

#[test]
fn test_document_insertion_and_retrieval() {
    // Use a simple test file path instead of tempfile
    let db_path = std::path::Path::new("test_roundtrip.db");
    
    // Clean up any existing test file
    if db_path.exists() {
        std::fs::remove_file(db_path).ok();
    }
    
    // Create database file
    let _db_file = DatabaseFile::create(db_path).expect("Failed to create database file");
    
    // Initialize storage engine
    let mut storage_engine = StorageEngine::new(db_path, 64)
        .expect("Failed to initialize storage engine");
    
    // Test 1: User document round-trip
    let mut user_doc = Document::new();
    user_doc.set("name", Value::String("Alice".to_string()));
    user_doc.set("age", Value::I32(28));
    user_doc.set("active", Value::Bool(true));
    user_doc.set("email", Value::String("alice@example.com".to_string()));
    
    // Insert user document
    let user_id = storage_engine.insert_document(&user_doc)
        .expect("Failed to insert user document");
    
    // Retrieve user document
    let retrieved_user = storage_engine.get_document(&user_id)
        .expect("Failed to retrieve user document");
    
    // Verify all fields match
    assert_eq!(user_doc.get("name"), retrieved_user.get("name"));
    assert_eq!(user_doc.get("age"), retrieved_user.get("age"));
    assert_eq!(user_doc.get("active"), retrieved_user.get("active"));
    assert_eq!(user_doc.get("email"), retrieved_user.get("email"));
    
    // Clean up test file
    drop(storage_engine);
    std::fs::remove_file(db_path).ok();
    
    // Test 2: Product document round-trip
    let mut product_doc = Document::new();
    product_doc.set("name", Value::String("Laptop".to_string()));
    product_doc.set("price", Value::F64(999.99));
    product_doc.set("stock", Value::I32(15));
    product_doc.set("category", Value::String("Electronics".to_string()));
    product_doc.set("available", Value::Bool(true));
    
    // Insert product document
    let product_id = storage_engine.insert_document(&product_doc)
        .expect("Failed to insert product document");
    
    // Retrieve product document
    let retrieved_product = storage_engine.get_document(&product_id)
        .expect("Failed to retrieve product document");
    
    // Verify all fields match
    assert_eq!(product_doc.get("name"), retrieved_product.get("name"));
    assert_eq!(product_doc.get("price"), retrieved_product.get("price"));
    assert_eq!(product_doc.get("stock"), retrieved_product.get("stock"));
    assert_eq!(product_doc.get("category"), retrieved_product.get("category"));
    assert_eq!(product_doc.get("available"), retrieved_product.get("available"));
}

#[test]
fn test_multiple_documents_same_page() {
    // Create a temporary directory for the test database
    let temp_dir = tempdir().expect("Failed to create temp directory");
    let db_path = temp_dir.path().join("test_multi_database.db");
    
    // Create database file
    let _db_file = DatabaseFile::create(&db_path).expect("Failed to create database file");
    
    // Initialize storage engine
    let mut storage_engine = StorageEngine::new(&db_path, 64)
        .expect("Failed to initialize storage engine");
    
    // Create multiple small documents
    let mut docs = Vec::new();
    let mut doc_ids = Vec::new();
    
    for i in 0..5 {
        let mut doc = Document::new();
        doc.set("id", Value::I32(i));
        doc.set("name", Value::String(format!("Item {}", i)));
        doc.set("value", Value::F64(i as f64 * 10.5));
        
        docs.push(doc);
    }
    
    // Insert all documents
    for doc in &docs {
        let doc_id = storage_engine.insert_document(doc)
            .expect("Failed to insert document");
        doc_ids.push(doc_id);
    }
    
    // Retrieve and verify all documents
    for (i, doc_id) in doc_ids.iter().enumerate() {
        let retrieved_doc = storage_engine.get_document(doc_id)
            .expect("Failed to retrieve document");
        
        let original_doc = &docs[i];
        
        assert_eq!(original_doc.get("id"), retrieved_doc.get("id"));
        assert_eq!(original_doc.get("name"), retrieved_doc.get("name"));
        assert_eq!(original_doc.get("value"), retrieved_doc.get("value"));
    }
}

#[test]
fn test_large_document_storage() {
    // Create a temporary directory for the test database
    let temp_dir = tempdir().expect("Failed to create temp directory");
    let db_path = temp_dir.path().join("test_large_database.db");
    
    // Create database file
    let _db_file = DatabaseFile::create(&db_path).expect("Failed to create database file");
    
    // Initialize storage engine
    let mut storage_engine = StorageEngine::new(&db_path, 64)
        .expect("Failed to initialize storage engine");
    
    // Create a larger document with more fields
    let mut large_doc = Document::new();
    large_doc.set("title", Value::String("A Very Long Document Title That Contains Many Words".to_string()));
    large_doc.set("description", Value::String("This is a longer description that contains multiple sentences. It has various pieces of information. The purpose is to test how the database handles larger documents with more content.".to_string()));
    large_doc.set("tags", Value::String("tag1,tag2,tag3,tag4,tag5,tag6,tag7,tag8,tag9,tag10".to_string()));
    large_doc.set("score", Value::F64(87.5));
    large_doc.set("count", Value::I32(12345));
    large_doc.set("enabled", Value::Bool(true));
    large_doc.set("metadata", Value::String("additional metadata information".to_string()));
    
    // Insert large document
    let large_doc_id = storage_engine.insert_document(&large_doc)
        .expect("Failed to insert large document");
    
    // Retrieve large document
    let retrieved_large = storage_engine.get_document(&large_doc_id)
        .expect("Failed to retrieve large document");
    
    // Verify all fields match
    assert_eq!(large_doc.get("title"), retrieved_large.get("title"));
    assert_eq!(large_doc.get("description"), retrieved_large.get("description"));
    assert_eq!(large_doc.get("tags"), retrieved_large.get("tags"));
    assert_eq!(large_doc.get("score"), retrieved_large.get("score"));
    assert_eq!(large_doc.get("count"), retrieved_large.get("count"));
    assert_eq!(large_doc.get("enabled"), retrieved_large.get("enabled"));
    assert_eq!(large_doc.get("metadata"), retrieved_large.get("metadata"));
}

#[test]
fn test_different_value_types() {
    // Create a temporary directory for the test database
    let temp_dir = tempdir().expect("Failed to create temp directory");
    let db_path = temp_dir.path().join("test_types_database.db");
    
    // Create database file
    let _db_file = DatabaseFile::create(&db_path).expect("Failed to create database file");
    
    // Initialize storage engine
    let mut storage_engine = StorageEngine::new(&db_path, 64)
        .expect("Failed to initialize storage engine");
    
    // Create document with all supported value types
    let mut type_doc = Document::new();
    type_doc.set("string_field", Value::String("test string".to_string()));
    type_doc.set("i32_field", Value::I32(-12345));
    type_doc.set("i64_field", Value::I64(-9876543210));
    type_doc.set("f64_field", Value::F64(3.14159));
    type_doc.set("bool_true", Value::Bool(true));
    type_doc.set("bool_false", Value::Bool(false));
    
    // Insert document with various types
    let type_doc_id = storage_engine.insert_document(&type_doc)
        .expect("Failed to insert type document");
    
    // Retrieve document
    let retrieved_type = storage_engine.get_document(&type_doc_id)
        .expect("Failed to retrieve type document");
    
    // Verify all types are preserved correctly
    assert_eq!(type_doc.get("string_field"), retrieved_type.get("string_field"));
    assert_eq!(type_doc.get("i32_field"), retrieved_type.get("i32_field"));
    assert_eq!(type_doc.get("i64_field"), retrieved_type.get("i64_field"));
    assert_eq!(type_doc.get("f64_field"), retrieved_type.get("f64_field"));
    assert_eq!(type_doc.get("bool_true"), retrieved_type.get("bool_true"));
    assert_eq!(type_doc.get("bool_false"), retrieved_type.get("bool_false"));
}